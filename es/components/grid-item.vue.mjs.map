{"version":3,"file":"grid-item.vue.mjs","sources":["../../src/components/grid-item.vue"],"sourcesContent":["<script setup lang=\"ts\">\r\nimport {\r\n  ref,\r\n  reactive,\r\n  toRef,\r\n  computed,\r\n  watch,\r\n  watchEffect,\r\n  inject,\r\n  onBeforeMount,\r\n  onMounted,\r\n  onBeforeUnmount\r\n} from 'vue'\r\nimport { isNull, nextTickOnce, throttle } from '@vexip-ui/utils'\r\nimport {\r\n  LAYOUT_KEY,\r\n  EMITTER_KEY,\r\n  setTopLeft,\r\n  setTopRight,\r\n  setTransformRtl,\r\n  setTransform,\r\n  useNameHelper\r\n} from '../helpers/common'\r\nimport { getControlPosition, createCoreData } from '../helpers/draggable'\r\nimport { getColsFromBreakpoint } from '../helpers/responsive'\r\nimport { getDocumentDir } from '../helpers/dom'\r\n\r\nimport Moveable from 'moveable'\r\n\r\nconst props = defineProps({\r\n  isDraggable: {\r\n    type: Boolean,\r\n    default: null\r\n  },\r\n  isResizable: {\r\n    type: Boolean,\r\n    default: null\r\n  },\r\n  isBounded: {\r\n    type: Boolean,\r\n    default: null\r\n  },\r\n  static: {\r\n    type: Boolean,\r\n    default: false\r\n  },\r\n  minH: {\r\n    type: Number,\r\n    default: 1\r\n  },\r\n  minW: {\r\n    type: Number,\r\n    default: 1\r\n  },\r\n  maxH: {\r\n    type: Number,\r\n    default: Infinity\r\n  },\r\n  maxW: {\r\n    type: Number,\r\n    default: Infinity\r\n  },\r\n  x: {\r\n    type: Number,\r\n    required: true\r\n  },\r\n  y: {\r\n    type: Number,\r\n    required: true\r\n  },\r\n  w: {\r\n    type: Number,\r\n    required: true\r\n  },\r\n  h: {\r\n    type: Number,\r\n    required: true\r\n  },\r\n  i: {\r\n    type: [Number, String],\r\n    required: true\r\n  }\r\n})\r\n\r\nconst emit = defineEmits(['container-resized', 'resize', 'resized', 'move', 'moved'])\r\n\r\nconst layout = inject(LAYOUT_KEY)\r\nconst emitter = inject(EMITTER_KEY)!\r\n\r\nif (!layout) {\r\n  throw new Error('[grid-layout-plus]: missing layout store, GridItem must under a GridLayout.')\r\n}\r\n\r\nconst interactObj = ref<InstanceType<typeof Moveable> | null>(null)\r\n\r\nconst state = reactive({\r\n  cols: 1,\r\n  containerWidth: 100,\r\n  rowHeight: 30,\r\n  margin: [10, 10],\r\n  maxRows: Infinity,\r\n  draggable: null as boolean | null,\r\n  resizable: null as boolean | null,\r\n  bounded: null as boolean | null,\r\n  transformScale: 1,\r\n  useCssTransforms: true,\r\n  useStyleCursor: true,\r\n\r\n  isDragging: false,\r\n  dragging: {\r\n    top: -1,\r\n    left: -1\r\n  },\r\n  isResizing: false,\r\n  resizing: {\r\n    width: -1,\r\n    height: -1\r\n  },\r\n  style: {} as Record<string, string>,\r\n  rtl: false\r\n})\r\n\r\nlet dragEventSet = false\r\nlet resizeEventSet = false\r\n\r\nlet lastX = NaN\r\nlet lastY = NaN\r\nlet lastW = NaN\r\nlet lastH = NaN\r\n\r\nlet previousW = -1\r\nlet previousH = -1\r\nlet previousX = -1\r\nlet previousY = -1\r\n\r\nlet innerX = props.x\r\nlet innerY = props.y\r\nlet innerW = props.w\r\nlet innerH = props.h\r\n\r\nconst wrapper = ref<HTMLElement>()\r\n\r\nconst instance = reactive({\r\n  i: toRef(props, 'i'),\r\n  state,\r\n  wrapper,\r\n  calcXY\r\n})\r\n\r\nfunction updateWidthHandler(width: number) {\r\n  updateWidth(width)\r\n}\r\n\r\nfunction compactHandler() {\r\n  compact()\r\n}\r\n\r\nfunction setDraggableHandler(isDraggable: boolean) {\r\n  if (isNull(props.isDraggable)) {\r\n    state.draggable = isDraggable\r\n  }\r\n}\r\n\r\nfunction setResizableHandler(isResizable: boolean) {\r\n  if (isNull(props.isResizable)) {\r\n    state.resizable = isResizable\r\n  }\r\n}\r\n\r\nfunction setBoundedHandler(isBounded: boolean) {\r\n  if (isNull(props.isBounded)) {\r\n    state.bounded = isBounded\r\n  }\r\n}\r\n\r\nfunction setTransformScaleHandler(transformScale: number) {\r\n  state.transformScale = transformScale\r\n}\r\n\r\nfunction setRowHeightHandler(rowHeight: number) {\r\n  state.rowHeight = rowHeight\r\n}\r\n\r\nfunction setMaxRowsHandler(maxRows: number) {\r\n  state.maxRows = maxRows\r\n}\r\n\r\nfunction directionchangeHandler() {\r\n  state.rtl = getDocumentDir() === 'rtl'\r\n  compact()\r\n}\r\n\r\nfunction setColNum(colNum: number) {\r\n  state.cols = Math.floor(colNum)\r\n}\r\n\r\nlayout.increaseItem(instance)\r\n\r\nonBeforeMount(() => {\r\n  state.rtl = getDocumentDir() === 'rtl'\r\n})\r\n\r\nonMounted(() => {\r\n  if (layout.responsive && layout.lastBreakpoint) {\r\n    state.cols = getColsFromBreakpoint(layout.lastBreakpoint, layout.cols)\r\n  } else {\r\n    state.cols = layout.colNum\r\n  }\r\n  state.rowHeight = layout.rowHeight\r\n  state.containerWidth = layout.width !== null ? layout.width : 100\r\n  state.margin = layout.margin !== undefined ? layout.margin.map(Number) : [10, 10]\r\n  state.maxRows = layout.maxRows\r\n\r\n  if (isNull(props.isDraggable)) {\r\n    state.draggable = layout.isDraggable\r\n  } else {\r\n    state.draggable = props.isDraggable\r\n  }\r\n  if (isNull(props.isResizable)) {\r\n    state.resizable = layout.isResizable\r\n  } else {\r\n    state.resizable = props.isResizable\r\n  }\r\n  if (isNull(props.isBounded)) {\r\n    state.bounded = layout.isBounded\r\n  } else {\r\n    state.bounded = props.isBounded\r\n  }\r\n  state.transformScale = layout.transformScale\r\n  state.useCssTransforms = layout.useCssTransforms\r\n  state.useStyleCursor = layout.useStyleCursor\r\n\r\n  watchEffect(() => {\r\n    innerX = props.x\r\n    innerY = props.y\r\n    innerH = props.h\r\n    innerW = props.w\r\n    nextTickOnce(createStyle)\r\n  })\r\n\r\n  emitter.on('updateWidth', updateWidthHandler)\r\n  emitter.on('compact', compactHandler)\r\n  emitter.on('setDraggable', setDraggableHandler)\r\n  emitter.on('setResizable', setResizableHandler)\r\n  emitter.on('setBounded', setBoundedHandler)\r\n  emitter.on('setTransformScale', setTransformScaleHandler)\r\n  emitter.on('setRowHeight', setRowHeightHandler)\r\n  emitter.on('setMaxRows', setMaxRowsHandler)\r\n  emitter.on('directionchange', directionchangeHandler)\r\n  emitter.on('setColNum', setColNum)\r\n})\r\n\r\nonBeforeUnmount(() => {\r\n  emitter.off('updateWidth', updateWidthHandler)\r\n  emitter.off('compact', compactHandler)\r\n  emitter.off('setDraggable', setDraggableHandler)\r\n  emitter.off('setResizable', setResizableHandler)\r\n  emitter.off('setBounded', setBoundedHandler)\r\n  emitter.off('setTransformScale', setTransformScaleHandler)\r\n  emitter.off('setRowHeight', setRowHeightHandler)\r\n  emitter.off('setMaxRows', setMaxRowsHandler)\r\n  emitter.off('directionchange', directionchangeHandler)\r\n  emitter.off('setColNum', setColNum)\r\n\r\n  if (interactObj.value) {\r\n    interactObj.value.destroy()\r\n  }\r\n\r\n  layout.decreaseItem(instance)\r\n})\r\n\r\ndefineExpose({ state, wrapper })\r\n\r\nconst isAndroid = navigator.userAgent.toLowerCase().includes('android')\r\n\r\nconst resizableAndNotStatic = computed(() => state.resizable && !props.static)\r\nconst renderRtl = computed(() => (layout.isMirrored ? !state.rtl : state.rtl))\r\nconst draggableOrResizableAndNotStatic = computed(() => {\r\n  return (state.draggable || state.resizable) && !props.static\r\n})\r\n\r\nconst nh = useNameHelper('item')\r\n\r\nconst className = computed(() => {\r\n  return {\r\n    [nh.b()]: true,\r\n    [nh.bm('resizable')]: resizableAndNotStatic.value,\r\n    [nh.bm('static')]: props.static,\r\n    [nh.bm('resizing')]: state.isResizing,\r\n    [nh.bm('dragging')]: state.isDragging,\r\n    [nh.bm('transform')]: state.useCssTransforms,\r\n    [nh.bm('rtl')]: renderRtl.value,\r\n    [nh.bm('no-touch')]: isAndroid && draggableOrResizableAndNotStatic.value\r\n  }\r\n})\r\nconst resizerClass = computed(() => {\r\n  // return renderRtl.value ? 'vue-resizable-handle vue-rtl-resizable-handle' : 'vue-resizable-handle'\r\n  return [nh.be('resizer'), renderRtl.value && nh.bem('resizer', 'rtl')].filter(Boolean)\r\n})\r\n\r\nwatch(\r\n  () => props.isDraggable,\r\n  value => {\r\n    state.draggable = value\r\n  }\r\n)\r\nwatch(\r\n  () => props.static,\r\n  () => {\r\n    nextTickOnce(tryMakeDraggable)\r\n    nextTickOnce(tryMakeResizable)\r\n  }\r\n)\r\nwatch(\r\n  () => state.draggable,\r\n  () => {\r\n    nextTickOnce(tryMakeDraggable)\r\n  }\r\n)\r\nwatch(\r\n  () => props.isResizable,\r\n  value => {\r\n    state.resizable = value\r\n  }\r\n)\r\nwatch(\r\n  () => props.isBounded,\r\n  value => {\r\n    state.bounded = value\r\n  }\r\n)\r\nwatch(\r\n  () => state.resizable,\r\n  () => {\r\n    nextTickOnce(tryMakeResizable)\r\n  }\r\n)\r\nwatch(\r\n  () => state.rowHeight,\r\n  () => {\r\n    nextTickOnce(createStyle)\r\n    nextTickOnce(emitContainerResized)\r\n  }\r\n)\r\nwatch([() => state.cols, () => state.containerWidth], () => {\r\n  nextTickOnce(tryMakeResizable)\r\n  nextTickOnce(createStyle)\r\n  nextTickOnce(emitContainerResized)\r\n})\r\nwatch([() => props.minH, () => props.maxH, () => props.minW, () => props.maxW], () => {\r\n  nextTickOnce(tryMakeResizable)\r\n})\r\nwatch(renderRtl, () => {\r\n  nextTickOnce(tryMakeResizable)\r\n  nextTickOnce(createStyle)\r\n})\r\nwatch([() => layout.margin, () => layout.margin[0], () => layout.margin[1]], () => {\r\n  const margin = layout.margin\r\n\r\n  if (!margin || (margin[0] === state.margin[0] && margin[1] === state.margin[1])) {\r\n    return\r\n  }\r\n\r\n  state.margin = margin.map(Number)\r\n  nextTickOnce(createStyle)\r\n  nextTickOnce(emitContainerResized)\r\n})\r\n\r\nfunction createStyle() {\r\n  if (props.x + props.w > state.cols) {\r\n    innerX = 0\r\n    innerW = props.w > state.cols ? state.cols : props.w\r\n  } else {\r\n    innerX = props.x\r\n    innerW = props.w\r\n  }\r\n\r\n  const pos = calcPosition(innerX, innerY, innerW, innerH)\r\n\r\n  if (state.isDragging) {\r\n    pos.top = state.dragging.top\r\n    // Add rtl support\r\n    if (renderRtl.value) {\r\n      pos.right = state.dragging.left\r\n    } else {\r\n      pos.left = state.dragging.left\r\n    }\r\n  }\r\n  if (state.isResizing) {\r\n    pos.width = state.resizing.width\r\n    pos.height = state.resizing.height\r\n  }\r\n\r\n  let style\r\n  // CSS Transforms support (default)\r\n  if (state.useCssTransforms) {\r\n    // Add rtl support\r\n    if (renderRtl.value) {\r\n      style = setTransformRtl(pos.top, pos.right!, pos.width, pos.height)\r\n    } else {\r\n      style = setTransform(pos.top, pos.left!, pos.width, pos.height)\r\n    }\r\n  } else {\r\n    // top,left (slow)\r\n    // Add rtl support\r\n    if (renderRtl.value) {\r\n      style = setTopRight(pos.top, pos.right!, pos.width, pos.height)\r\n    } else {\r\n      style = setTopLeft(pos.top, pos.left!, pos.width, pos.height)\r\n    }\r\n  }\r\n\r\n  state.style = style\r\n}\r\n\r\nfunction emitContainerResized() {\r\n  // this.style has width and height with trailing 'px'. The\r\n  // resized event is without them\r\n  const styleProps: Record<string, string> = {}\r\n  for (const prop of ['width', 'height']) {\r\n    const val = state.style[prop]\r\n    const matches = val.match(/^(\\d+)px$/)\r\n    if (!matches) {\r\n      return\r\n    }\r\n    styleProps[prop] = matches[1]\r\n  }\r\n  emit('container-resized', props.i, props.h, props.w, styleProps.height, styleProps.width)\r\n}\r\n\r\nfunction handleResize(event: any, type: string) {\r\n  if (props.static) return\r\n\r\n  if (\r\n    (type === 'resizestart' && state.isResizing) ||\r\n    (type !== 'resizestart' && !state.isResizing)\r\n  ) {\r\n    return\r\n  }\r\n\r\n  const position = getControlPosition(event)\r\n  // Get the current drag point from the event. This is used as the offset.\r\n  if (isNull(position)) return // not possible but satisfies flow\r\n\r\n  const { x, y } = position\r\n  const newSize = { width: 0, height: 0 }\r\n  let pos\r\n  switch (type) {\r\n    case 'resizestart': {\r\n      tryMakeResizable()\r\n      previousW = innerW\r\n      previousH = innerH\r\n      pos = calcPosition(innerX, innerY, innerW, innerH)\r\n      newSize.width = pos.width\r\n      newSize.height = pos.height\r\n      state.resizing = newSize\r\n      state.isResizing = true\r\n      break\r\n    }\r\n    case 'resizemove': {\r\n      const coreEvent = createCoreData(lastW, lastH, x, y)\r\n      if (renderRtl.value) {\r\n        newSize.width = state.resizing.width - coreEvent.deltaX / state.transformScale\r\n      } else {\r\n        newSize.width = state.resizing.width + coreEvent.deltaX / state.transformScale\r\n      }\r\n      newSize.height = state.resizing.height + coreEvent.deltaY / state.transformScale\r\n      state.resizing = newSize\r\n      break\r\n    }\r\n    case 'resizeend': {\r\n      pos = calcPosition(innerX, innerY, innerW, innerH)\r\n      newSize.width = pos.width\r\n      newSize.height = pos.height\r\n\r\n      state.resizing = { width: -1, height: -1 }\r\n      state.isResizing = false\r\n      break\r\n    }\r\n  }\r\n\r\n  // Get new WH\r\n  pos = calcWH(newSize.height, newSize.width)\r\n  if (pos.w < props.minW) {\r\n    pos.w = props.minW\r\n  }\r\n  if (pos.w > props.maxW) {\r\n    pos.w = props.maxW\r\n  }\r\n  if (pos.h < props.minH) {\r\n    pos.h = props.minH\r\n  }\r\n  if (pos.h > props.maxH) {\r\n    pos.h = props.maxH\r\n  }\r\n\r\n  if (pos.h < 1) {\r\n    pos.h = 1\r\n  }\r\n  if (pos.w < 1) {\r\n    pos.w = 1\r\n  }\r\n\r\n  lastW = x\r\n  lastH = y\r\n\r\n  if (innerW !== pos.w || innerH !== pos.h) {\r\n    emit('resize', props.i, pos.h, pos.w, newSize.height, newSize.width)\r\n  }\r\n  if (type === 'resizeend' && (previousW !== innerW || previousH !== innerH)) {\r\n    emit('resized', props.i, pos.h, pos.w, newSize.height, newSize.width)\r\n  }\r\n  emitter.emit('resizeEvent', type, props.i, innerX, innerY, pos.h, pos.w)\r\n}\r\n\r\nfunction handleDrag(event: any, type: string) {\r\n  if (props.static || state.isResizing) return\r\n\r\n  if ((type === 'dragstart' && state.isDragging) || (type !== 'dragstart' && !state.isDragging)) {\r\n    return\r\n  }\r\n\r\n  const position = getControlPosition(event)\r\n\r\n  // Get the current drag point from the event. This is used as the offset.\r\n  if (isNull(position)) return // not possible but satisfies flow\r\n  const { x, y } = position\r\n  const target = event.target as HTMLElement\r\n\r\n  if (!target.offsetParent) return\r\n\r\n  // let shouldUpdate = false;\r\n  const newPosition = { top: 0, left: 0 }\r\n  switch (type) {\r\n    case 'dragstart': {\r\n      previousX = innerX\r\n      previousY = innerY\r\n\r\n      const parentRect = target.offsetParent.getBoundingClientRect()\r\n      const clientRect = target.getBoundingClientRect()\r\n\r\n      const cLeft = clientRect.left / state.transformScale\r\n      const pLeft = parentRect.left / state.transformScale\r\n      const cRight = clientRect.right / state.transformScale\r\n      const pRight = parentRect.right / state.transformScale\r\n      const cTop = clientRect.top / state.transformScale\r\n      const pTop = parentRect.top / state.transformScale\r\n\r\n      if (renderRtl.value) {\r\n        newPosition.left = (cRight - pRight) * -1\r\n      } else {\r\n        newPosition.left = cLeft - pLeft\r\n      }\r\n      newPosition.top = cTop - pTop\r\n      state.dragging = newPosition\r\n      state.isDragging = true\r\n      break\r\n    }\r\n    case 'dragmove': {\r\n      const coreEvent = createCoreData(lastX, lastY, x, y)\r\n      // Add rtl support\r\n      if (renderRtl.value) {\r\n        newPosition.left = state.dragging.left - coreEvent.deltaX / state.transformScale\r\n      } else {\r\n        newPosition.left = state.dragging.left + coreEvent.deltaX / state.transformScale\r\n      }\r\n      newPosition.top = state.dragging.top + coreEvent.deltaY / state.transformScale\r\n      if (state.bounded) {\r\n        const bottomBoundary =\r\n          target.offsetParent.clientHeight -\r\n          calcGridItemWHPx(props.h, state.rowHeight, state.margin[1])\r\n        newPosition.top = clamp(newPosition.top, 0, bottomBoundary)\r\n        const colWidth = calcColWidth()\r\n        const rightBoundary =\r\n          state.containerWidth - calcGridItemWHPx(props.w, colWidth, state.margin[0])\r\n        newPosition.left = clamp(newPosition.left, 0, rightBoundary)\r\n      }\r\n\r\n      state.dragging = newPosition\r\n      break\r\n    }\r\n    case 'dragend': {\r\n      const parentRect = target.offsetParent.getBoundingClientRect()\r\n      const clientRect = target.getBoundingClientRect()\r\n\r\n      const cLeft = clientRect.left / state.transformScale\r\n      const pLeft = parentRect.left / state.transformScale\r\n      const cRight = clientRect.right / state.transformScale\r\n      const pRight = parentRect.right / state.transformScale\r\n      const cTop = clientRect.top / state.transformScale\r\n      const pTop = parentRect.top / state.transformScale\r\n\r\n      // Add rtl support\r\n      if (renderRtl.value) {\r\n        newPosition.left = (cRight - pRight) * -1\r\n      } else {\r\n        newPosition.left = cLeft - pLeft\r\n      }\r\n      newPosition.top = cTop - pTop\r\n      state.dragging = { top: -1, left: -1 }\r\n      state.isDragging = false\r\n      break\r\n    }\r\n  }\r\n\r\n  // Get new XY\r\n  let pos\r\n  if (renderRtl.value) {\r\n    pos = calcXY(newPosition.top, newPosition.left)\r\n  } else {\r\n    pos = calcXY(newPosition.top, newPosition.left)\r\n  }\r\n\r\n  lastX = x\r\n  lastY = y\r\n\r\n  if (innerX !== pos.x || innerY !== pos.y) {\r\n    emit('move', props.i, pos.x, pos.y)\r\n  }\r\n  if (type === 'dragend' && (previousX !== innerX || previousY !== innerY)) {\r\n    emit('moved', props.i, pos.x, pos.y)\r\n  }\r\n  emitter.emit('dragEvent', type, props.i, pos.x, pos.y, innerH, innerW)\r\n}\r\n\r\nfunction calcPosition(x: number, y: number, w: number, h: number) {\r\n  const colWidth = calcColWidth()\r\n  // add rtl support\r\n  let out\r\n  if (renderRtl.value) {\r\n    out = {\r\n      right: Math.round(colWidth * x + (x + 1) * state.margin[0]),\r\n      top: Math.round(state.rowHeight * y + (y + 1) * state.margin[1]),\r\n      // 0 * Infinity === NaN, which causes problems with resize constraints;\r\n      // Fix this if it occurs.\r\n      // Note we do it here rather than later because Math.round(Infinity) causes depot\r\n      width: w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * state.margin[0]),\r\n      height:\r\n        h === Infinity ? h : Math.round(state.rowHeight * h + Math.max(0, h - 1) * state.margin[1])\r\n    }\r\n  } else {\r\n    out = {\r\n      left: Math.round(colWidth * x + (x + 1) * state.margin[0]),\r\n      top: Math.round(state.rowHeight * y + (y + 1) * state.margin[1]),\r\n      // 0 * Infinity === NaN, which causes problems with resize constraints;\r\n      // Fix this if it occurs.\r\n      // Note we do it here rather than later because Math.round(Infinity) causes depot\r\n      width: w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * state.margin[0]),\r\n      height:\r\n        h === Infinity ? h : Math.round(state.rowHeight * h + Math.max(0, h - 1) * state.margin[1])\r\n    }\r\n  }\r\n\r\n  return out\r\n}\r\n\r\n/**\r\n * Translate x and y coordinates from pixels to grid units.\r\n * @param top  Top position (relative to parent) in pixels.\r\n * @param left Left position (relative to parent) in pixels.\r\n * @return x and y in grid units.\r\n */\r\n// TODO check if this function needs change in order to support rtl.\r\nfunction calcXY(top: number, left: number) {\r\n  const colWidth = calcColWidth()\r\n\r\n  // left = colWidth * x + margin * (x + 1)\r\n  // l = cx + m(x+1)\r\n  // l = cx + mx + m\r\n  // l - m = cx + mx\r\n  // l - m = x(c + m)\r\n  // (l - m) / (c + m) = x\r\n  // x = (left - margin) / (coldWidth + margin)\r\n  let x = Math.round((left - state.margin[0]) / (colWidth + state.margin[0]))\r\n  let y = Math.round((top - state.margin[1]) / (state.rowHeight + state.margin[1]))\r\n\r\n  // Capping\r\n  x = Math.max(Math.min(x, state.cols - innerW), 0)\r\n  y = Math.max(Math.min(y, state.maxRows - innerH), 0)\r\n\r\n  return { x, y }\r\n}\r\n\r\nfunction calcColWidth() {\r\n  return (state.containerWidth - state.margin[0] * (state.cols + 1)) / state.cols\r\n}\r\n\r\nfunction calcGridItemWHPx(gridUnits: number, colOrRowSize: number, marginPx: number) {\r\n  // 0 * Infinity === NaN, which causes problems with resize constraints\r\n  if (!Number.isFinite(gridUnits)) return gridUnits\r\n  return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx)\r\n}\r\n\r\nfunction clamp(num: number, lowerBound: number, upperBound: number) {\r\n  return Math.max(Math.min(num, upperBound), lowerBound)\r\n}\r\n\r\n/**\r\n * Given a height and width in pixel values, calculate grid units.\r\n * @param height Height in pixels.\r\n * @param width  Width in pixels.\r\n * @param autoSizeFlag  function autoSize identifier.\r\n * @return w, h as grid units.\r\n */\r\nfunction calcWH(height: number, width: number, autoSizeFlag = false) {\r\n  const colWidth = calcColWidth()\r\n\r\n  // width = colWidth * w - (margin * (w - 1))\r\n  // ...\r\n  // w = (width + margin) / (colWidth + margin)\r\n  let w = Math.round((width + state.margin[0]) / (colWidth + state.margin[0]))\r\n  let h = 0\r\n  if (!autoSizeFlag) {\r\n    h = Math.round((height + state.margin[1]) / (state.rowHeight + state.margin[1]))\r\n  } else {\r\n    h = Math.ceil((height + state.margin[1]) / (state.rowHeight + state.margin[1]))\r\n  }\r\n\r\n  // Capping\r\n  w = Math.max(Math.min(w, state.cols - innerX), 0)\r\n  h = Math.max(Math.min(h, state.maxRows - innerY), 0)\r\n  return { w, h }\r\n}\r\n\r\nfunction updateWidth(width: number, colNum?: number) {\r\n  state.containerWidth = width\r\n  if (colNum !== undefined && colNum !== null) {\r\n    state.cols = colNum\r\n  }\r\n}\r\n\r\nfunction compact() {\r\n  createStyle()\r\n}\r\n\r\nfunction tryInteract() {\r\n  if (!interactObj.value && wrapper.value) {\r\n    // @ts-ignore\r\n    interactObj.value = new Moveable(document.body, {\r\n      target: wrapper.value,\r\n      hideDefaultLines: true,\r\n      origin: false\r\n    })\r\n  }\r\n}\r\n\r\nconst throttleDrag = throttle(handleDrag)\r\n\r\nfunction tryMakeDraggable() {\r\n  tryInteract()\r\n\r\n  if (!interactObj.value) return\r\n\r\n  if (state.draggable && !props.static) {\r\n    interactObj.value.setState({\r\n      draggable: true\r\n    })\r\n\r\n    if (!dragEventSet) {\r\n      dragEventSet = true\r\n\r\n      interactObj.value\r\n        .on('dragStart', e => handleDrag(e, 'dragstart'))\r\n        .on('drag', e => throttleDrag(e, 'dragmove'))\r\n        .on('dragEnd', e => handleDrag(e, 'dragend'))\r\n    }\r\n  } else {\r\n    interactObj.value.setState({\r\n      draggable: false\r\n    })\r\n  }\r\n}\r\n\r\nconst throttleResize = throttle(handleResize)\r\n\r\nfunction tryMakeResizable() {\r\n  tryInteract()\r\n\r\n  if (!interactObj.value) return\r\n\r\n  if (state.resizable && !props.static) {\r\n    interactObj.value.setState({\r\n      resizable: true\r\n    })\r\n    if (!resizeEventSet) {\r\n      resizeEventSet = true\r\n      interactObj.value\r\n        .on('resizeStart', e => handleResize(e, 'resizestart'))\r\n        .on('resize', e => throttleResize(e, 'resizemove'))\r\n        .on('resizeEnd', e => handleResize(e, 'resizeend'))\r\n    }\r\n  } else {\r\n    interactObj.value.setState({\r\n      resizable: false\r\n    })\r\n  }\r\n}\r\n</script>\r\n\r\n<template>\r\n  <section ref=\"wrapper\" :class=\"className\" :style=\"state.style\">\r\n    <slot></slot>\r\n    <span v-if=\"resizableAndNotStatic\" :class=\"resizerClass\"></span>\r\n  </section>\r\n</template>\r\n"],"names":["layout","inject","LAYOUT_KEY","emitter","EMITTER_KEY","interactObj","ref","state","reactive","dragEventSet","resizeEventSet","lastX","lastY","lastW","lastH","previousW","previousH","previousX","previousY","innerX","props","innerY","innerW","innerH","wrapper","instance","toRef","calcXY","updateWidthHandler","width","updateWidth","compactHandler","compact","setDraggableHandler","isDraggable","isNull","setResizableHandler","isResizable","setBoundedHandler","isBounded","setTransformScaleHandler","transformScale","setRowHeightHandler","rowHeight","setMaxRowsHandler","maxRows","directionchangeHandler","getDocumentDir","setColNum","colNum","onBeforeMount","onMounted","getColsFromBreakpoint","watchEffect","nextTickOnce","createStyle","onBeforeUnmount","expose","isAndroid","resizableAndNotStatic","computed","renderRtl","draggableOrResizableAndNotStatic","nh","useNameHelper","className","resizerClass","watch","value","tryMakeDraggable","tryMakeResizable","emitContainerResized","margin","pos","calcPosition","style","setTransformRtl","setTransform","setTopRight","setTopLeft","styleProps","prop","matches","emit","handleResize","event","type","position","getControlPosition","x","y","newSize","coreEvent","createCoreData","calcWH","handleDrag","target","newPosition","parentRect","clientRect","cLeft","pLeft","cRight","pRight","cTop","pTop","bottomBoundary","calcGridItemWHPx","clamp","colWidth","calcColWidth","rightBoundary","w","h","out","top","left","gridUnits","colOrRowSize","marginPx","num","lowerBound","upperBound","height","autoSizeFlag","tryInteract","Moveable","throttleDrag","throttle","e","throttleResize"],"mappings":"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"}